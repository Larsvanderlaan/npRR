"0","risks_all <- list()"
"0","for(i in 1:10) {"
"0","  # Generate data"
"0","  n <- 5000"
"0","#   V <- as.matrix(replicate(3,runif(n, min = -1, max = 1)))"
"0","#   X <- V"
"0","#   A <- rbinom(n, size = 1, prob = 0.12+ 0.75*plogis(sin(5*(V^2 %*% c(-1,-1,-1))) + sin(5*(V %*% c(1,-1,1))) + 0.5*cos(5*(V %*% c(-1,1,1)))^2 + sin(5*V) %*% c(1,1,-1) + cos(5*V) %*% c(1,1,1)))"
"0","#   Y <- rbinom(n, size = 1, prob = 0.05 + 0.9*plogis(0.9*(-0.5 + A + 0.3*A*(sin(3.5*V) %*% c(1,-1,1) + cos(3.5*V) %*% c(1,-1,1)) + sin(3*V) %*% c(-1,1,1) + cos(3*V) %*% c(1,1,-1))))"
"0","#  "
"0","# bound <- Vectorize(tmle3::bound)"
"0","D <- DAG.empty()"
"0","D <- DAG.empty()"
"0"," "
"0",""
"0","# hard_additive"
"0","theta = function(W1, W2, W3) {0.5*(W1+cos(4*W1)) + 0.5*sin(4*W2) + 0.5*sin(4*W3)}"
"0"," "
"0","theta <- Vectorize(theta)"
"0",""
"0","key <- ""hard_additive"""
"0","D <- D +"
"0","  node(""W1"", distr = ""runif"", min = -1, max = 1) +"
"0","  node(""W2"", distr = ""runif"", min = -1, max = 1) +"
"0","  node(""W3"", distr = ""runif"", min = -1, max = 1) +"
"0","  node(""g"", distr = ""rconst"", const = 0.15 + 0.75*plogis(cos((W1+W2 + W3)*5) * sin((W1+W2 + W3)*5) + cos((W1+W2 + W3)*5) + sin((W1+W2 + W3)*5) + sin(W1*5) + W1*sin(W1*5) + cos(W2*5) + 2*W1*W2 - sin(W3*5) + sin(5*W1*W3) + 2*W1*W2*W3 + W3*sin(W1*5) + cos(W2*4)*sin(W1*5) ) ) +"
"0","  node(""A"", distr = ""rbinom"", size = 1, prob = g )+"
"0","   node(""phi"", distr = ""rconst"", const = (1+W1 + W2)*sin(W1*5)  + (1+W2 + W3)*cos(5*W2) + 0.5*exp(W1*W2) + cos(6*W1*W3)+ sin(6*W3*W2) + sin(6*W1*W2) + W3*sin(5*W3) + W2*sin(5*W3)) +"
"0","  node(""theta"", distr = ""rconst"", const =  theta(W1,W2,W3))+"
"0","    node(""gRtilde0"", distr = ""rconst"",  const = (-(exp(theta) + 1)*exp(phi) + (exp(2*phi)*(exp(theta) + 1)^2 + 4*(exp(theta + phi))*(1 - exp(phi)))^(0.5))/(2*exp(theta)*(1-exp(phi)))"
"0","           ) +"
"0","   node(""gRtilde1"", distr = ""rconst"",  const =    gRtilde0*exp(theta)) +"
"0","   node(""gRtilde"", distr = ""rconst"",  const =   A*gRtilde1 + (1-A)*gRtilde0) +"
"0","   node(""gR"", distr = ""rconst"",  const =  gRtilde ) +"
"0","  node(""R"", distr = ""rbinom"", size = 1, prob = gR)+"
"0","  node(""RR"", distr = ""rconst"", const = gRtilde1/gRtilde0)"
"0",""
"0","setD <- set.DAG(D, vecfun = c(""bound"", ""round"", ""theta""))"
"0","data <- sim(setD, n = n)"
"0"," "
"0","  ##################"
"0","  ###################   WORKS"
"0","  #A <- rbinom(n, size = 1, prob = 0.2+ 0.6*plogis(sin(5*(V %*% c(1,1,1))) + 0.5*cos(5*(V %*% c(1,1,1)))^2 + sin(5*V) %*% c(1,1,1) + cos(5*V) %*% c(1,1,1)))"
"0","  #Y <- rbinom(n, size = 1, prob = 0.05 + 0.9*plogis(0.9*(-0.5 + A + 0.3*A*(sin(3.5*V) %*% c(1,-1,1) + cos(3.5*V) %*% c(1,-1,1)) + sin(3*V) %*% c(-1,1,1) + cos(3*V) %*% c(1,1,-1))))"
"0","    ##################"
"0","    ##################"
"0","  Y <- data$R"
"0","  A <- data$A"
"0","  V <- as.matrix(data[, c(""W1"", ""W2"", ""W3"")])"
"0","  X <- V"
"0","  "
"0","  Q1 <- data$gRtilde1"
"0","  Q0 <- data$gRtilde0"
"0","  Q <- data$gRtilde"
"0","  g1 <- data$g"
"0","  "
"0","  lrnr_A <- Lrnr_hal9001$new(max_degree = 2, smoothness_orders = 1, num_knots = c(10, 5))"
"0","  lrnr_Y <- Lrnr_hal9001$new(max_degree = 2, smoothness_orders = 1, num_knots = c(10, 5))"
"0","  #Stack$new(Lrnr_xgboost$new(max_depth = 7), Lrnr_xgboost$new(max_depth = 3), Lrnr_xgboost$new(max_depth = 6), Lrnr_xgboost$new(max_depth = 5), Lrnr_xgboost$new(max_depth = 4))"
"0","  "
"0","  task <- make_task(V, X, A, Y, folds = 5)"
"0","  likelihood <- make_likelihood(task, lrnr_A ,lrnr_Y, cv = F)"
"0","  genr <- make_generator(likelihood)"
"0","  task_RR <- genr(task, ""validation"")"
"0","  # Q <- 0.05 + 0.9*plogis(0.9*(-0.5 + A + 0.3*A*(sin(3.5*V) %*% c(1,-1,1) + cos(3.5*V) %*% c(1,-1,1)) + sin(3*V) %*% c(-1,1,1) + cos(3*V) %*% c(1,1,-1)))"
"0","  # A <- 1"
"0","  # Q1 <- 0.05 + 0.9*plogis(0.9*(-0.5 + A + 0.3*A*(sin(3.5*V) %*% c(1,-1,1) + cos(3.5*V) %*% c(1,-1,1)) + sin(3*V) %*% c(-1,1,1) + cos(3*V) %*% c(1,1,-1)))"
"0","  # A <- 0"
"0","  # Q0 <- 0.05 + 0.9*plogis(0.9*(-0.5 + A + 0.3*A*(sin(3.5*V) %*% c(1,-1,1) + cos(3.5*V) %*% c(1,-1,1)) + sin(3*V) %*% c(-1,1,1) + cos(3*V) %*% c(1,1,-1)))"
"0","  #  A <- task$get_tmle_node(""A"")"
"0","  # g1 <- 0.12+ 0.75*plogis(sin(5*(V^2 %*% c(-1,-1,-1))) + sin(5*(V %*% c(1,-1,1))) + 0.5*cos(5*(V %*% c(-1,1,1)))^2 + sin(5*V) %*% c(1,1,-1) + cos(5*V) %*% c(1,1,1))"
"0","  "
"0","  # "
"0","  basis1 <- fourier_basis$new(orders = c(1,0,0), max_degrees = c(1,2,3))"
"0","  basis2 <- fourier_basis$new(orders = c(1,1,0), max_degrees = c(1,2,3))"
"0","  basis3 <- fourier_basis$new(orders = c(2,1,0), max_degrees = c(1,2,3))"
"0","  basis4 <- fourier_basis$new(orders = c(3,1,0), max_degrees = c(1,2,3))"
"0","  basis5 <- fourier_basis$new(orders = c(3,2,0), max_degrees = c(1,2,3))"
"0","  basis6 <- fourier_basis$new(orders = c(3,2,1), max_degrees = c(1,2,3))"
"0","  basis_list <- list(""k=0"" = NULL,""k=1""= basis1,"
"0","                     ""k=2"" = basis2, "
"0","                     ""k=3"" =basis3,"
"0","                     ""k=4"" =basis4,"
"0","                     ""k=5"" =basis5,"
"0","                     ""k=6"" =basis6)"
"0"," "
"0","  lrnr <- Stack$new(Lrnr_weight_helper$new(lrnr = Lrnr_LRR_xgboost$new(max_depth = 4, nrounds = 20), name = ""xgboost_4""),"
"0","                    Lrnr_weight_helper$new(lrnr =Lrnr_LRR_xgboost$new(max_depth = 3, nrounds = 20), name = ""xgboost_3""),"
"0","            make_learner(Pipeline,lrnr_SL.gam1, Lrnr_chainer_link$new()),"
"0","   Lrnr_weight_helper$new(lrnr = Lrnr_LRR_hal9001$new(max_degree = 1, smoothness_orders =1, num_knots = c(15)), name = ""hal9001_1""),"
"0","                       make_learner(Pipeline,lrnr_SL.gam2, Lrnr_chainer_link$new()),"
"0","                                                   make_learner(Pipeline,lrnr_SL.glm, Lrnr_chainer_link$new()),"
"0","   make_learner(Pipeline,lrnr_SL.inter, Lrnr_chainer_link$new())"
"0","                                                  "
"0","  )"
"0","  lrnrs <- list()"
"0","  for(name in names(basis_list)) {"
"0","    basis <- basis_list[[name]]"
"0","    if(is.null(basis)) {"
"0","      lrnr_sieve <- NULL"
"0","    } else {"
"0","      lrnr_sieve <- Lrnr_adaptive_sieve$new(basis_generator = basis,mult_by = c(""Qg1"", ""Qg0""))"
"0","    }"
"0","    lrr_IPW <- LRR_IPW_task_generator$new(sieve_learner = lrnr_sieve, name = name)"
"0"," "
"0","    lrnrs <- c(lrnrs, list(Pipeline$new(lrr_IPW, lrnr$clone())))"
"0","    "
"0","     if(is.null(basis)) {"
"0","      lrnr_sieve <- NULL"
"0","    } else {"
"0","      lrnr_sieve <- Lrnr_adaptive_sieve$new(basis_generator = basis,stratify_by = ""A"", mult_by = ""ginv"")"
"0","    }"
"0","    lrr_plugin <- LRR_plugin_task_generator$new(sieve_learner = lrnr_sieve, name = name)"
"0","     "
"0","    lrnrs <- c(lrnrs, list(Pipeline$new(lrr_plugin, lrnr$clone())))"
"0","    "
"0","    "
"0","  }"
"0","  lrnr_lrr <- make_learner(Stack, lrnrs)"
"0","  "
"0","  lrnr_lrr <- lrnr_lrr$train(task_RR)"
"0","  preds <- lrnr_lrr$predict(task_RR)"
"0","  "
"0","  "
"0","  risks <- apply(preds, 2 , function(preds) {"
"0","  f <- preds"
"0","  gRtilde1 <- Q1"
"0","  gRtilde0 <- Q0"
"0","  gRtilde0 <- bound(gRtilde0, 0.01)"
"0","  gRtilde1 <- bound(gRtilde1, 0.01)"
"0","  f0 = log(gRtilde1/gRtilde0)"
"0","  loss <- (f0-f)^2"
"0","  return(mean(loss))"
"0","})"
"0","  risks_all[[i]] <- risks"
"0","  "
"0","  "
"0","}"
"2","...automatically assigning order attribute to some nodes...
"
"2","node W1, order:1
"
"2","node W2, order:2
"
"2","node W3, order:3
"
"2","node g, order:4
"
"2","node A, order:5
"
"2","node phi, order:6
"
"2","node theta, order:7
"
"2","node gRtilde0, order:8
"
"2","node gRtilde1, order:9
"
"2","node gRtilde, order:10
"
"2","node gR, order:11
"
"2","node R, order:12
"
"2","node RR, order:13
"
"1","[1]"
"1"," ""current list of user-defined vectorized functions: bound,round,theta"""
"1","
"
"2","simulating observed dataset from the DAG object
"
